'use strict';

const btn = document.querySelector('.btn-country');
const countriesContainer = document.querySelector('.countries');

const renderCountry = function (data, className = ' ') {
  const html = `
<article class="country ${className}">
  <img class="country__img" src="${data.flag}" />
  <div class="country__data">
    <h3 class="country__name">${data.name}</h3>
    <h4 class="country__region">${data.region}</h4>
    <p class="country__row"><span>ğŸ‘«</span>${(
      +data.population / 1000000
    ).toFixed(1)}M people</p>
    <p class="country__row"><span>ğŸ—£ï¸</span>${data.languages
      .map(el => el.name)
      .join(', ')}</p>
    <p class="country__row"><span>ğŸ’°</span>${data.currencies
      .map(el => el.name)
      .join(', ')}</p>
  </div>
</article>`;

  countriesContainer.insertAdjacentHTML('beforeend', html);
  countriesContainer.style.opacity = '1';
};

const renderError = function (msg) {
  countriesContainer.insertAdjacentText('beforeend', msg);
  // countriesContainer.style.opacity = 1;
};

btn.addEventListener('click', function () {
  getCountryData('United States');
});

///////////////////////////////////////
//THE OLD SCHOOL WAY OF DOING AJAX: XMLHttpRequest-function

/*
//AJAX call country 1;
const getCountryAndNeighbour = function (country) {
  const request = new XMLHttpRequest();
  request.open('GET', `https://countries-api-836d.onrender.com/countries/name/${country}`);
  request.send();

  request.addEventListener('load', function () {
    const [data] = JSON.parse(this.responseText);
    console.log(data);

    //render country 1;
    renderCountry(data);

    //Get neighbour country (2)
    const neighbour = data.borders?.[0];
    if (!neighbour) return;
    //AJAX call country 2
    const request2 = new XMLHttpRequest();
    request2.open('GET', `https://countries-api-836d.onrender.com/countries/alpha/${neighbour}`);
    request2.send();
    request2.addEventListener('load', function () {
      const data2 = JSON.parse(this.responseText);
      console.log(data2);
      //render country 2;
      renderCountry(data2, 'neighbour');
    });
  });
};

// getCountryData('belgium');
getCountryAndNeighbour('portugal');
// getCountryData('france');
// getCountryData('spain');
// getCountryData('canada');
// getCountryData('cuba');
// getCountryData('usa');
*/

//THE MODERN WAY OF CALLING API:

// const request = new XMLHttpRequest();
// request.open('GET', `https://countries-api-836d.onrender.com/countries/name/${country}`);
// request.send();

// const request = fetch('https://countries-api-836d.onrender.com/countries/name/portugal');
// console.log(request);
// //the fetch API inmediately created a promise.
// const getCountryData = function (country) {
//   fetch(`https://countries-api-836d.onrender.com/countries/name/${country}`)
//     .then(function (response) {
//       console.log(response);
//       return response.json();
//     })
//     .then(function (data) {
//       console.log(data);
//     });
// };

// const request = fetch('https://countries-api-836d.onrender.com/countries/name/portugal');
// console.log(request);
//the fetch API inmediately created a promise.

/*
// --- test to see how long it takes to fulfill the promise ---
let counter = 0;
let intervalId;

function myFunction(a) {
  console.log(a);
  counter++;
  if (counter >= 2) {
    clearInterval(intervalId);
  }
}
function start() {
  intervalId = setTimeout(() => myFunction(request), 190);
}

start();
*/

/*
//CONSUMING A FULFILLED PROMISE:
// the then-method is available on al promises (i.e. the return of fetch).
// it receives the promis as an argument, named response in this example, for its callback function. 

// const getCountryData = function (country){
//   fetch(`https://countries-api-836d.onrender.com/countries/name/${country}`)
//   .then(function(response){
//     console.log(response);
//   })
// };

// at this point we cannot read the response.
// we need to call the JSON method on the response(fulfilled promis).
// however, the json method is also an async function and will itself return a promis.
// which, in its turn must be handeled by a then-method.

// const getCountryData = function (country){
//   fetch(`https://countries-api-836d.onrender.com/countries/name/${country}`)
//   .then(function(response){
//     // call JSON method on response
//     return response.json()
//   })
//   // handle the promis generated by the JSON method
//   // data is is the response passed on from the JSON method
//   .then(function(data){
//     renderCountry(data[0])
//   });
// };

// simplified version:

const getCountryData = function (country){
  fetch(`https://countries-api-836d.onrender.com/countries/name/${country}`)
  .then(response => response.json())
  .then(data => renderCountry(data[0]));
};

getCountryData('portugal');
*/

//CHAINING PROMISES

// const getCountryData = function (country) {
//   //COUNTRY 1:
//   fetch(`https://countries-api-836d.onrender.com/countries/name/${country}`)
//     .then(response => response.json())
//     .then(data => {
//       renderCountry(data[0]);
//       //create a new variable for the neighbour country
//       const neighbour = data[0].borders?.[0];
//       if (!neighbour) return;
//       // COUNTRY 2;
//       // return fetch(
//       //   `https://countries-api-836d.onrender.com/countries/name/${neighbour}`
//       // );
//     })
//     //outside the callback function, chain a new then method.
//     //if you chain it inside the callback function, we are back to callback-hell.
//     .then(response => response.json())
//     .then(data => renderCountry(data[0], 'neighbour'));
// };

// getCountryData('portugal');

/* 
//HOW TO HANDLE PROMIS REJECTIONS.

//IMPORTANT: the only way in which the FETCH-promis rejects, is when user loses connection.
//method 1: 2nd argument of the fetch method can be a callback function handling the error.
// the callback function receives the error as an argument

//method 2: at the end of the chain use the CATCH-method.
// Errors fall through the chain untill they are caught.
// the catch method at the and will receive the error as an argument.
*/

/*
// THE FINALLY METHOD
// is activated at the end, regardless of fulfillment or rejection.
// it serves to execute code at the end of the chain that has to be executed in all cases.

*/

/* 
//THROWING MANUAL ERRORS


const getCountryData = function (country){
  //COUNTRY 1:
  fetch(`https://countries-api-836d.onrender.com/countries/name/${country}`)
  .then(response => {
  //if response is not ok (ok is a boolean property on on the response object)
  //throw an error, which will result in instant rejection of the promis.  
    if(!response.ok)
    throw new Error(`country not found (${response.status})`)

    return response.json()})
  .then(data => {
    renderCountry(data[0]);
  //create a new variable for the neighbour country
  const neighbour = data[0].borders?.[0];
  if (!neighbour) return;
  // COUNTRY 2;
  return fetch(`https://countries-api-836d.onrender.com/countries/name/${neighbour}`);
  })
  //outside the callback function, chain a new then method.
  //if you chain it inside the callback function, we are back to callback-hell.
  .then(response => {  
    if(!response.ok)
    throw new Error(`country not found (${response.status})`)
    return response.json()})
  .then(data => renderCountry(data[0], 'neighbour'))
  .catch(err => {
      renderError(`Something went wrong ğŸ¤¬ ${err.message} ğŸ¤¬`);
      console.error(`${err} ğŸ¤¬ğŸ¤¬`);
    })
  .finally(() => {
      countriesContainer.style.opacity = 1;
    });
};

getCountryData('portugal');

*/
/*
//CREATE getJSON HELPER FUNCTION:

const getJSON = function (url, errorMsg = 'Something went wrong') {
  return fetch(url).then(response => {
    if (!response.ok) throw new Error(`${errorMsg} (${response.status})`);
    console.log(response);
    return response.json();
  });
};

const getCountryData = function (country) {
  // Country 1
  getJShttps://countries-api-836d.onrender.com/countries/name/${country}`, 'Country not found.')
    .then(data => {
      console.log(data);
      console.log(data[0]);
      renderCountry(data[0]);
      const neighbour = data[0].borders?.[0];
      if (!neighbour) throw new Error('No neighbour found!');
      // Country 2
      return getJSON(
  https://countries-api-836d.onrender.com/countries/alpha/${neighbour}`,
        'Country not found.'
      );
    })
    .then(data => renderCountry(data, 'neighbour'))
    .catch(err => {
      renderError(`Something went wrong ğŸ¤¬ ${err.message} ğŸ¤¬`);
      console.error(`${err} ğŸ¤¬ğŸ¤¬`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
};
*/
/*
Asynchronous JavaScript
Coding Challenge #1
In this challenge you will build a function 'whereAmI' which renders a country only based on GPS coordinates. 
For that, you will use a second API to geocode coordinates. 
So in this challenge, youâ€™ll use an API on your own for the first time ğŸ˜

Your tasks:

PART 1
1. Create a function 'whereAmI' which takes as inputs a latitude value('lat') and a longitude value ('lng')
(these are GPS coordinates, examples are in test data below).

2. Do â€œreverse geocodingâ€ of the provided coordinates. Reverse geocoding means to convert coordinates to a meaningful location,
like a city and country name. Use this API to do reverse geocoding: https://geocode.xyz/api.
The AJAX call will be done to a URL with this format: https://geocode.xyz/52.508,13.381?geoit=json. 
Use the fetch API and promises to get the data. 
Do not use the 'getJSON' function we created, that is cheating ğŸ˜‰

3. Once you have the data, take a look at it in the console to see all the attributes that you received about the provided location.
Then, using this data, log a message like this to the console: â€œYou are in Berlin, Germanyâ€

4. Chain a .catch method to the end of the promise chain and log errors to the console

5. This API allows you to make only 3 requests per second. If you reload fast, you will get this error with code 403. 
This is an error with the request. Remember, fetch() does not reject the promise in this case. 
So create an error to reject the promise yourself, with a meaningful error message

PART 2
6. Now it's time to use the received data to render a country. So take the relevant attribute from the geocoding API result,
and plug it into the countries API that we have been using.

7. Render the country and catch any errors, just like we have done in the last lecture 
(you can even copy this code, no need to type the same code)

Test data:
Â§ Coordinates 1: 52.508, 13.381 (Latitude, Longitude) 
Â§ Coordinates 2: 19.037, 72.873
Â§ Coordinates 3: -33.933, 18.474
GOOD LUCK ğŸ˜€

*/

/*
const whereAmI = function (lat, lng) {
  return fetch(`https://geocode.maps.co/reverse?lat=${lat}&lon=${lng}`)
    .then(response => {
      if (!response.ok)
        throw new Error(`location not found ${response.status}`);
      // console.log(response);
      return response.json();
    })
    .then(data => {
      if (data.error)
        throw new Error(
          `cover me in flour and eggs and bake me for 14 minutes: ${data.error}`
        );
      // console.log(data);
      // console.log(data.address.country);
      // console.log(data.address.city);
      const country = data?.address?.country_code;
      return fetch (`https://countries-api-836d.onrender.com/countries/alpha/${country}`);
    })
    .then(response => {
      if (!response.ok)
        throw new Error(`Country not found (${response.status})`);
      return response.json();
    })
    .then(data => {
      renderCountry(data);
    })
    .catch(err => {
      renderError(`Something went wrong ğŸ¤¬ ${err.message} ğŸ¤¬`);
      console.error(`${err} ğŸ¤¬ğŸ¤¬`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
};

whereAmI(52.508, 13.381);
whereAmI(19.037, 72.873);
whereAmI(-33.933, 18.471);
*/

/*
const lotteryPromise = new Promise(function (resolve, reject) {
  console.log('lottery draw in progresss...');
  setTimeout(() => {
    if (Math.random() >= 0.5) {
      resolve('You won! ğŸ¤‘');
    } else {
      reject('You lost! ğŸ’©');
    }
  }, 2000);
});

lotteryPromise.then(res => console.log(res)).catch(err => console.error(err));
*/
//Promisifying setTimeout
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000);
  });
};

/*
//ESCAPING CALL BACK HELL
wait(1)
  .then(() => {
    console.log('I waited for 1 seconds');
    return wait(1);
  })
  .then(() => {
    console.log('I waited for 2 seconds');
    return wait(1);
  })
  .then(() => {
    console.log('I waited for 3 seconds');
    return wait(1);
  })
  .then(() => console.log('I waited for 4 seconds'));

Promise.resolve('yeeha').then(x => console.log(x)); // then is for resolved promises.
Promise.reject(new Error('meeha')).catch(x => console.error(x)); // catch is for errors and rejected promises.

//Promisifying the GEOLOCATION API
//callback
navigator.geolocation?.getCurrentPosition(
  position => console.log(position),
  err => console.error(err)
);

//promise (returns faster than the callback)
const getPosition = function () {
  return new Promise(function (resolve, reject) {
    navigator.geolocation?.getCurrentPosition(resolve, reject);
  });
};

getPosition().then(pos => console.log(pos));
*/

/* CODING CHALLENGE 2

const imgContainer = document.querySelector('.images');

const createImage = function (imgPath) {
  return new Promise(function (resolve, reject) {
    const img = document.createElement('img');
    img.src = imgPath;
    img.addEventListener('load', () => {
      imgContainer.appendChild(img);
      resolve(img);
    });
    img.addEventListener('error', err =>
      reject(new Error(`something went wrong: ${err.message}`))
    );
  });
};

let currentImage;

createImage('../img/img-1.jpg')
  .then(img => {
    currentImage = img;
    return wait(2);
  })
  .then(() => {
    currentImage.style.display = 'none';
    return createImage('../img/img-2.jpg');
  })
  .then(img => {
    currentImage = img;
    return wait(2);
  })
  .then(() => (currentImage.style.display = 'none'))
  .catch(err => console.error(err));
*/

/*
// ASYNC / AWAIT

const getPosition = function () {
  return new Promise(function (resolve, reject) {
    navigator.geolocation?.getCurrentPosition(resolve, reject);
  });
};

//by adding async the function will run asynchronously and return a promise at the end.
const whereAmI = async function (country) {
  try {
    //see further for explanation.

    // Geolocation
    const pos = await getPosition();
    const { latitude: lat, longitude: lng } = pos.coords;

    //Reverse geocoding
    const resGeo = await fetch(
      `https://geocode.maps.co/reverse?lat=${lat}&lon=${lng}`
    );
    if (!resGeo.ok) throw new Error('Problem getting location data.');
    const dataGeo = await resGeo.json();

    //inside an async function we can have 1 or more await statements.
    //the await keyword lets the code run in the background.
    const res = await fetch(
      `https://countries-api-836d.onrender.com/countries/name/${dataGeo.address.country}`
    );
    if (!res.ok) throw new Error('Problem getting country.');
    const data = await res.json();
    renderCountry(data[0]);

    return `You are in ${dataGeo.address.city}, ${dataGeo.address.country}`;
  } catch (err) {
    console.error(`${err} ğŸ¤¬`);
    renderError(`ğŸ¤¬ ${err.message}`);

    //Reject promise returned from async function:
    throw err;
  }
  // //above is exactly the same as following:
  
  // fetch(
  //   `https://countries-api-836d.onrender.com/countries/name/${dataGeo.address.country}`
  // )
  //   .then(res => {
  //     if(!res.ok) throw new Error('Problem getting country.');
  //     console.log(res);
  //     return res.json();
  //   })
  //   .then(data => renderCountry(data[0]))
  //   .catch( err => {
  //     console.error(`${err} ğŸ¤¬`); 
  //     renderError(`ğŸ¤¬ ${err.message}`);
  //   });
};

//executing our function:
console.log(`1: will get location`);
// whereAmI()
//   .then(city => console.log(`2: ${city}`))
//   .catch(err => console.error(`2: ${err.message}`))
//   .finally(() => console.log('3: Finished getting location'));

//rewriting without .then() and using async/await:
(async () => {
  try {
    const city = await whereAmI();
    console.log(`2: ${city}`);
  } catch (err) {
    console.error(`2: ${err.message}`);
  }
  console.log('3: Finished getting location');
})();

//HANDLING ERRORS WITH TRY...CATCH
//we can wrap all our code in a try block
try {
  let y = 1;
  const x = 2;
  y = 3;
} catch (err) {
  console.error(err);
}
//the catch block has access to the error that occured in the try block.

//RUNNING PROMISES CODE IN PARALLEL:
//helper function:
const getJSON = function (url, errorMsg = 'Something went wrong') {
  return fetch(url).then(response => {
    if (!response.ok) throw new Error(`${errorMsg} (${response.status})`);
    // console.log(response);
    return response.json();
  });
};

const get3Countries = async function (c1, c2, c3) {
  try {
    // const [data1] = await getJSON(
    //   `https://countries-api-836d.onrender.com/countries/name/${c1}`
    // );
    // const [data2] = await getJSON(
    //   `https://countries-api-836d.onrender.com/countries/name/${c2}`
    // );
    // const [data3] = await getJSON(
    //   `https://countries-api-836d.onrender.com/countries/name/${c3}`
    // );

    //Promise.all() takes an array of promises and will return an new promise.
    const dataAll = await Promise.all([
      getJSON(`https://countries-api-836d.onrender.com/countries/name/${c1}`),
      getJSON(`https://countries-api-836d.onrender.com/countries/name/${c2}`),
      getJSON(`https://countries-api-836d.onrender.com/countries/name/${c3}`),
    ]);
    //Promise.all() short-circuits if 1 promise rejects.

    // console.log([data1.capital, data2.capital, data3.capital]);
    console.log(dataAll.map(d => d[0].capital));
  } catch (err) {
    console.error(err);
  }
};

get3Countries('mozambique', 'cameroon', 'tanzania');

//always run async function in parallel when possible.

//3 PROMISE COMBINATORS: RACE, ALLSETTLED AND ANY;

//Promice.race
//the first function that SETTLES wins the race.

(async () => {
  const res = await Promise.race([
    getJSON(`https://countries-api-836d.onrender.com/countries/name/italy`),
    getJSON(`https://countries-api-836d.onrender.com/countries/name/gabon`),
    getJSON(`https://countries-api-836d.onrender.com/countries/name/thailand`),
  ]);
  console.log(res[0]);
})();

const timeout = function (sec) {
  return new Promise(function (_, reject) {
    setTimeout(function () {
      reject(new Error('Request took too long'));
    }, sec * 1000);
  });
};

//real world example: reject promise if the request takes more than 5 seconds
Promise.race([
  getJSON(`https://countries-api-836d.onrender.com/countries/name/thailand`),
  timeout(5),
])
  .then(res => console.log(res[0]))
  .catch(err => console.error(err));

//Promise.allSettled
//takes an array of promises and returns an array of settled promises. It does not short circuit, unlike promise.all.

//will give array
Promise.allSettled([
  Promise.resolve('success'),
  Promise.reject('ERROR'),
  Promise.resolve('Another success'),
]).then(res => console.log(res));

//will give error
Promise.all([
  Promise.resolve('success'),
  Promise.reject('ERROR'),
  Promise.resolve('Another success'),
])
  .then(res => console.log(res))
  .catch(err => console.error(err));

//Promise.any
//returns the first resolved promise, ignoring rejected promises.
//unlike promise.race, which will return the first settled promise, either resolved or rejected.
Promise.any([
  Promise.resolve('success'),
  Promise.reject('ERROR'),
  Promise.resolve('Another success'),
])
  .then(res => console.log(res))
  .catch(err => console.error(err));
*/

//CODING CHALLENGE 3

//PART 1:

// const imgContainer = document.querySelector('.images');

// const createImage = function (imgPath) {
//   return new Promise(function (resolve, reject) {
//     const img = document.createElement('img');
//     img.src = imgPath;
//     img.addEventListener('load', () => {
//       imgContainer.appendChild(img);
//       resolve(img);
//     });
//     img.addEventListener('error', err =>
//       reject(new Error(`something went wrong: ${err.message}`))
//     );
//   });
// };

const imageContainer = document.querySelector('.images');

const createImage = function (imgPath) {
  return new Promise(function (resolve, reject) {
    const img = document.createElement('img');
    img.src = imgPath;
    img.addEventListener('load', () => {
      imageContainer.appendChild(img);
      resolve(img);
    });
    img.addEventListener('error', err => reject(new Error(err.message)));
  });
};

const loadNpause = async function () {
  try {
    let img = await createImage('../img/img-1.jpg');
    await wait(2);
    img.style.display = 'none';
    img = await createImage('../img/img-2.jpg');
    img.style.display = 'block';
    await wait(2);
    img.style.display = 'none';
  } catch (err) {
    console.error(err);
  }
};

// loadNpause();

//PART 2:
const imgArr = ['img/img-1.jpg', 'img/img-2.jpg', 'img/img-3.jpg'];

const loadAll = async function (args) {
  try {
    const imgs = args.map(async el => await createImage(el));
    const imgsAll = await Promise.all(imgs);
    imgsAll.forEach(img => img.classList.add('parallel'));
  } catch (err) {
    console.error(err);
  }
};

loadAll(imgArr);
